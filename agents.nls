extensions[matrix]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
  cost_per_patch  ; The cost per patch for this bus type
  capacity        ; The capacity of the bus
  
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).
  pick_up_passenger_group ; The passenger groups that the bus is going to pick up
  
  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  buses_count     ; The amount of other busses that exist
  message_protocol; The variable that is going to contain the message
  score_list      ; List that contains scores for every bus stop 
  buses_database
  max_score
  wait_counter     ; simple shared tick counter used between functions
  maximum-score-busstop ; the maximum score and the next busstop, which will be sent to all buses
  second_choice   ; boolean indicating to go for the first or second choice
  
  tree-score     ; Ugly variables because netlogo doesn't allow recursive report functions rip
  tree-group     ;
  
  claimed_passengers ; list of claimed passenger_ids
]
 
globals [graph]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Initialize and perform actions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initialize agents and variables  
to init-buses

  set-cost-per-patch
  set-bus-capacity
  set wait_counter 0
  set second_choice false
  
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
    
  set buses_count bus_id - length graph + 1 ; Set current amount of busses
  send-initial-message ; Send message to all other existing busses to let know that a new bus exists
  set buses_database n-values buses_count [[]]
  
  calculate-scores ; Calculate score for connected bus stops
  set-next-stop ; Determine next bus stop (highest score)
  
  set maximum-score-busstop []
  
  set claimed_passengers []
 
end 

; Add decision making strategies for your agents here.
; You are allowed to use the global variable 'ticks'.
to execute-actions 
  read-inbox
  
  ifelse wait_counter > 0 
   [
     set wait_counter wait_counter - 1
     show "wait counter from loop: "
     show wait_counter  
   ]
   [
   if current_stop != -1 ; If the bus is at a bus stop
    [     
     calculate-scores
     request-score
     set-next-stop
     communicate-claim
     ;show next_stop
     ;show pick_up_passenger_group
     ;show score_list
    ] 
   travel-to-stop
   drop-off-passengers
   pick-up-passengers
   ]

      ;show buses_database
  send-initial-message
      ;show message_protocol ; debug
      ;show bus_passengers?
      
      
  write "BUS_ID"
  show bus_id
  write "CLAIM_LIST"
  show claimed_passengers
    
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Inbox ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Creates the message to be sent
to create-message
  set message_protocol (list "Bus type:" bus_type "Bus passengers:" bus_passengers "Previous stop: " previous_stop "Current stop: " current_stop "Next stop: " next_stop); ; Message protocol containing all variables that need sharing, strings added temporarily for readability
end

; Send message to other buses to let them know this bus exists
to send-initial-message 
  let id length graph 
  while [ id < bus_id ] [
   create-message
   send-message id message_protocol
   set id id + 1
  ]
end

; Read the inbox
to read-inbox
  
  foreach inbox [
    
; If a request for score is received, calculate score and send this back if it's higher
   if member? "request" item 2 ? [
     show "I received a score request!"
     let templist(item 2 ?)
     ;show item 1 item 1 templist ; returns the bus stop number sent by the requestee 
     ; todo calculate scores for specific bus stop     
     let requested-score (list 7.14 16 [1 7]) ; static for now because I'm not sure how to calculate scores for one specific bus stop (item 1 item 1 templist)
     ;show "requested-score: "
     ;show requested-score
     show templist
     if (item 0 requested-score) > item 0 item 1 templist [ ; Compare newly calculated score with the score of the bus that asked for it
       send-message (item 1 ?) (list "response" requested-score) ;Send a message back to the bus with the requested score
       show "Sent a message back to bus#: "
       show (item 1 ?)
       ]     
     ]
 
; If we received a response  
   if member? "response" item 2 ? [
     show "I received a response!"
     set second_choice true;
     ; Go for second choice
     ; Else go for first choice
     ]
   
; If we received a claim  
   if member? "claim" item 2 ? [
     let claims item 1 item 2 ?
     foreach claims ; add to existing claim list
     [
       set claimed_passengers lput ? claimed_passengers
     ]
   ]
   
   
   if item 1 ? - length graph + 1 > buses_count [ ; Check if message from new bus is received 
     set buses_count item 1 ? - length graph + 1  ; Updates buses_count
   ]

   ifelse (item 1 ? - length graph + 1) > length(buses_database) [
    set buses_database lput ? buses_database
   ]
   [
   set buses_database replace-item (item 1 ? - length graph) buses_database ?
   ]
  ]
  set inbox []
end

to request-score
  ifelse wait_counter = 0 
  [
    set wait_counter -1
  ]
  [
    let id 0
    while [ id < buses_count ] [    
      if (id + length graph) != bus_id [
        send-message (id + length graph) (list "request" max_score)
        show (list "request" max_score)
        set wait_counter 3 ; Set a wait counter 
        ]
      set id id + 1   
    ]
  ]  
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Route ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set the next stop according to score
to set-next-stop

  ifelse second_choice = false  
  [
     ifelse (max n-values length(score_list) [item 0 item ? score_list]) > 0 [
       foreach score_list
       [
         if item 0 ? = max n-values length(score_list) [item 0 item ? score_list]
         [
           set max_score(list item 0 ? item 1 ? item 2 ?)
           set next_stop item 1 ?
           set pick_up_passenger_group item 2 ?
           write "pick_up_passenger_group"
           show pick_up_passenger_group
         ]
       ]
     ]
     [
       set next_stop one-of item current_stop graph ; Choose random connected bus stop (Why is this still in here?)
     ]
   ]
   [
     show "I should go for my second choice"
     show "Max n-values"
     show max n-values length(score_list) [item 0 item ? score_list]
     show "N-values list"
     show n-values length(score_list) [item 0 item ? score_list]
     foreach score_list
     [
       if item 0 ? = max n-values length(score_list) [item 0 item ? score_list]
       [
         ;set score_list remove (item 0 ?) score_list ; Remove the item from the list - ERROR: Expected list of size X, not size X-1
         ;set score_list replace-item (item 0 ?) score_list 0 ; OR Replace the max score with a lower score - NOT WORKING YET                  
         show "new score_list: "
         show n-values length(score_list) [item 0 item ? score_list]
       ]
     ]                         
   ]
end

to travel-to-stop
  if (wait_counter = 0) or (wait_counter = -1)
  [
    travel-to next_stop
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Passenger actions (pick up/drop off) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Pick up every passenger at the stop until bus is full
to pick-up-passengers
  if current_stop != -1 ; Check if bus is currently at a stop 
  [
    foreach get-passengers-at-stop current_stop
    [
      if length bus_passengers < bus_type3_capacity ; If the bus is not full
      [
        if member? item 1 ? pick_up_passenger_group ; Pick up when in passenger group
        [
          pick-up-passenger item 0 ? ; Pick up the passenger
        ]
      ]
    ]
  ]
end

; Drop off every passenger that has arrived at its destination
to drop-off-passengers 
  if current_stop != -1 ; Check if bus is currently at a stop 
  [
    foreach bus_passengers
    [
      if item 1 ? = current_stop ; If a passenger is at its destination
      [
        drop-off-passenger item 0 ? ; Drop off
      ]
    ]
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Calculate Score ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to calculate-scores
  set maximum-score-busstop []
  
  if current_stop != -1
  [
    let s0 ( list item current_stop xs item current_stop ys ) ; Current stop coordinates s0
    
    ; Weights of the route vector
    let passenger_group_count n-values length(graph) [ 0 ]
    foreach bus_passengers
    [ 
      set passenger_group_count replace-item (item 1 ?) passenger_group_count (item item 1 ? passenger_group_count + 1) 
    ]

    ; Estimated route vector r0 (weighted average of destination of passengers on board)
    let r0 ( list 0 0 ) 
    ifelse sum(passenger_group_count) > 0 ; If there are passengers on board
    [
      foreach n-values length(graph) [ ? ]
      [
        let xw item ? xs * item ? passenger_group_count
        let yw item ? ys * item ? passenger_group_count
        set r0 ( list (item 0 r0 + xw) (item 1 r0 + yw) )
      ]
      set r0 ( list (item 0 r0 / sum(passenger_group_count) ) (item 1 r0 / sum(passenger_group_count) ) )
    ]
    [
      set r0 s0 ; If there are no passengers on board set the estimated route equal to the current stop
    ]
    
    let scores []

    foreach (item current_stop graph) ; Get possible next stops
    [
      let stop_number ?
      let s1 ( list item ? xs item ? ys ) ; Next stop coordinates s1
      
      ; Weights of the route vector r1
      let passenger_group_count_s1 n-values length(graph) [ 0 ]
          foreach get-passengers-at-stop ?
          [ 
            set passenger_group_count_s1 replace-item (item 1 ?) passenger_group_count_s1 (item item 1 ? passenger_group_count_s1 + 1) 
          ]
          
      ; Passenger groups of s1
      let passenger_groups []
      foreach n-values length(graph) [ ? ]
      [
        if item ? passenger_group_count_s1 > 0 ; If passenger with destination ?
        [
          set passenger_groups lput (list (?) (item ? passenger_group_count_s1) ) passenger_groups ; Destination, count
        ]
      ]
      
      let scoresr1 []
      let powerset []  
       
       
      ifelse length passenger_groups < 10 ; Pick acceptable treshold
      [
        set powerset calculate-power-set passenger_groups

        foreach powerset
        [
          let r1 ( list 0 0 )
          let counter 0
          foreach ?
          [
            let xw item item 0 ? xs * item 1 ?
            let yw item item 0 ? ys * item 1 ?
            set r1 ( list ( item 0 r0 + xw ) ( item 1 r0 + yw ) )
            set counter counter + item 1 ?
          ]
          ifelse counter > 0
          [
            set r1 ( list ( item 0 r1 / counter ) ( item 1 r1 / counter ) )
          ]
          [
            set r1 s1
          ]
          
          let drop_off_count item stop_number passenger_group_count
          let pick_up_count counter
          if capacity - length(bus_passengers) < counter - drop_off_count
          [
            set pick_up_count capacity - length(bus_passengers) + drop_off_count
          ] 
          
          let vs0s1 ( list ( item 0 s1 - item 0 s0 ) ( item 1 s1 - item 1 s0 ) )
          let vs0r0 ( list ( item 0 r0 - item 0 s0 ) ( item 1 r0 - item 1 s0 ) )
          let vs1r0 ( list ( item 0 r0 - item 0 s1 ) ( item 1 r0 - item 1 s1 ) )
          let vs1r1 ( list ( item 0 r1 - item 0 s1 ) ( item 1 r1 - item 1 s1 ) )
          if pick_up_count < 1
          [
            set vs1r1 vs1r0
          ]
          
          
          let vs0s1*vs0r0 ( item 0 vs0s1 * item 0 vs0r0 ) + ( item 1 vs0s1 * item 1 vs0r0 )
          let vs1r0*vs1r1 ( item 0 vs1r0 * item 0 vs1r1 ) + ( item 1 vs1r0 * item 1 vs1r1 )
          
          let len_vs0s1 sqrt( (item 0 vs0s1) ^ 2 + (item 1 vs0s1) ^ 2 ) + 1
          let len_vs1r1 sqrt( (item 0 vs1r1) ^ 2 + (item 1 vs1r1) ^ 2 ) + 1
          let len_vs0r0 sqrt( (item 0 vs0r0) ^ 2 + (item 1 vs0r0) ^ 2 ) + 1
          let len_vs1r0 sqrt( (item 0 vs1r0) ^ 2 + (item 1 vs1r0) ^ 2 ) + 1
          
          let scorer1 ( 1 / cost_per_patch ) * ( 1 + drop_off_count ) * ln( 1 + exp( vs0s1*vs0r0 / len_vs0s1 ^ 2 ) ) + ( 1 + pick_up_count ) * ln( 1 + exp( vs1r0*vs1r1 / len_vs1r1 ^ 2 ) )
          
          set scoresr1 lput scorer1 scoresr1
        ]
      ]
      [ ; If more then 10 passenger groups        
        set tree-score 0
        
        let single_groups []
        
        foreach passenger_groups
        [
          set single_groups lput ( list ? ) single_groups
        ]

        score-tree-search single_groups stop_number
        
        set scoresr1 lput tree-score scoresr1
        set powerset ( list tree-group )
      ]
      

        let maximum max scoresr1
        let argmax position max scoresr1 scoresr1
        let pickup_groups []
        
        foreach item argmax powerset
        [
          ifelse length(?) > 0
          [
            set pickup_groups lput item 0 ? pickup_groups
          ]
          [
            set pickup_groups lput [] pickup_groups
          ]
        ]
        set scores lput ( list maximum stop_number pickup_groups ) scores
      

      
      ; set maximum score, along with busstop and passenger group, to communicate with other buses
      ifelse length(maximum-score-busstop) = 0
      [
        set maximum-score-busstop ( list maximum stop_number pickup_groups )
      ]
      [
        if maximum > item 0 maximum-score-busstop
        [
          set maximum-score-busstop ( list maximum stop_number pickup_groups )
          ;print "New maximum score"
          ;show maximum-score-busstop
        ]
      ]
    ]
    set score_list scores
  ]
end



; Set the travelling cost per patch of the current bus
to set-cost-per-patch
  if bus_type = 1
  [set cost_per_patch bus_type1_cost_per_patch]
  if bus_type = 2
  [set cost_per_patch bus_type2_cost_per_patch]
  if bus_type = 3
  [set cost_per_patch bus_type3_cost_per_patch]
end

; Set the passenger capacity of the current bus
to set-bus-capacity
  if bus_type = 1
  [set capacity bus_type1_capacity]
  if bus_type = 2
  [set capacity bus_type2_capacity]
  if bus_type = 3
  [set capacity bus_type3_capacity]
end

; Calculate the power set of a list of passenger-groups, containg integers ranging from 0-23
to-report calculate-power-set [ passenger-groups ]
  let power-set [[]] ; init with empty list
  
  foreach passenger-groups ; loop through all passenger groups
  [
   let pass-group ? ; an element of passenger-group
   let new-sets [] ; init new sets to be added to the power set
   foreach power-set ; loop through all current power sets
   [
     let subset ? ; an element of power-set
     ; if current power set does not contain current passenger group, add it
     if not member? pass-group subset [
        set subset lput pass-group subset
     ]
     
     ; if current (new) set does not contain current power set, add it
     if not member? subset new-sets [
       set new-sets lput subset new-sets
     ]
   ]

   foreach new-sets ; add new sets to current power set (no built-in function for 'extend')
   [
     set power-set lput ? power-set
   ]
  ]
  
set power-set remove-duplicates power-set ; remove duplicates
report power-set ; return the local variable
end



to score-tree-search [ passenger_groups stop_number ]
  let scoresr1 []
  
  if length passenger_groups > 1
  [
    foreach passenger_groups
    [
      let scorer1 score (list ?) stop_number
      set scoresr1 lput item 0 scorer1 scoresr1
    ]  
    
    let maximum_group item position max scoresr1 scoresr1 passenger_groups
    
    set passenger_groups remove-item position maximum_group passenger_groups passenger_groups
    
    foreach passenger_groups
    [
      set passenger_groups replace-item position ? passenger_groups passenger_groups lput item 0 maximum_group ?
    ]
    
     let scoreg1 score passenger_groups stop_number 

     if max scoreg1 > tree-score
     [
       set tree-score max scoreg1
       set tree-group item position max scoreg1 scoreg1 passenger_groups
     ]
 
    score-tree-search passenger_groups stop_number
  ]
end


to-report score [ passenger_groups stop_number ]
  let scoresr1 []
  if current_stop != -1
  [
    let s0 ( list item current_stop xs item current_stop ys ) ; Current stop coordinates s0
    
    ; Weights of the route vector
    let passenger_group_count n-values length(graph) [ 0 ]
    foreach bus_passengers
    [ 
      set passenger_group_count replace-item (item 1 ?) passenger_group_count (item item 1 ? passenger_group_count + 1) 
    ]

    ; Estimated route vector r0 (weighted average of destination of passengers on board)
    let r0 ( list 0 0 ) 
    ifelse sum(passenger_group_count) > 0 ; If there are passengers on board
    [
      foreach n-values length(graph) [ ? ]
      [
        let xw item ? xs * item ? passenger_group_count
        let yw item ? ys * item ? passenger_group_count
        set r0 ( list (item 0 r0 + xw) (item 1 r0 + yw) )
      ]
      set r0 ( list (item 0 r0 / sum(passenger_group_count) ) (item 1 r0 / sum(passenger_group_count) ) )
    ]
    [
      set r0 s0 ; If there are no passengers on board set the estimated route equal to the current stop
    ]
    
    let scores []

    let s1 ( list item stop_number xs item stop_number ys ) ; Next stop coordinates s1
    

    foreach passenger_groups
    [
      let r1 ( list 0 0 )
      let counter 0
      foreach ?
      [
        let xw item item 0 ? xs * item 1 ?
        let yw item item 0 ? ys * item 1 ?
        set r1 ( list (item 0 r0 + xw) (item 1 r0 + yw) )
        set counter counter + item 1 ?
      ]
      ifelse counter > 0
      [
      set r1 ( list (item 0 r1 / counter ) (item 1 r1 / counter ) )
      ]
      [
        set r1 s1
      ]
      
      let drop_off_count item stop_number passenger_group_count
      let pick_up_count counter
      if capacity - length(bus_passengers) < counter - drop_off_count
      [
        set pick_up_count capacity - length(bus_passengers) + drop_off_count
      ] 
      
      let vs0s1 ( list (item 0 s1 - item 0 s0 ) (item 1 s1 - item 1 s0 ) )
      let vs0r0 ( list (item 0 r0 - item 0 s0 ) (item 1 r0 - item 1 s0 ) )
      let vs1r0 ( list (item 0 r0 - item 0 s1 ) (item 1 r0 - item 1 s1 ) )
      let vs1r1 ( list (item 0 r1 - item 0 s1 ) (item 1 r1 - item 1 s1 ) )
      if pick_up_count < 1
      [
        set vs1r1 vs1r0
      ]
      
      
      let vs0s1*vs0r0 ( item 0 vs0s1 * item 0 vs0r0 ) + ( item 1 vs0s1 * item 1 vs0r0 )
      let vs1r0*vs1r1 ( item 0 vs1r0 * item 0 vs1r1 ) + ( item 1 vs1r0 * item 1 vs1r1 )
      
      let len_vs0s1 sqrt( (item 0 vs0s1) ^ 2 + (item 1 vs0s1) ^ 2 ) + 1
      let len_vs1r1 sqrt( (item 0 vs1r1) ^ 2 + (item 1 vs1r1) ^ 2 ) + 1
      let len_vs0r0 sqrt( (item 0 vs0r0) ^ 2 + (item 1 vs0r0) ^ 2 ) + 1
      let len_vs1r0 sqrt( (item 0 vs1r0) ^ 2 + (item 1 vs1r0) ^ 2 ) + 1
      
      let scorer1 (1 / cost_per_patch) * ( 1 + drop_off_count ) * ln( 1 + exp( vs0s1*vs0r0 / len_vs0s1 ^ 2 ) ) + ( 1 + pick_up_count ) * ln( 1 + exp( vs1r0*vs1r1 / len_vs1r1 ^ 2 ) )
      
      set scoresr1 lput scorer1 scoresr1
    ]
  ]
  report scoresr1
end

; find the corresponding passenger ids of a given list of passenger groups to be claimed 
to-report claim-passenger-ids [ busstop claim_passenger_groups ]
  let passenger-ids [] ; init
  let busstop_passengers get-passengers-at-stop busstop ; returns a list of tuples of the form [passenger_id bus_stop]
  foreach busstop_passengers ; loop through passengers at busstop
  [
    let passenger_id item 0 ?
    let destination item 1 ?
    if member? destination claim_passenger_groups ; if destination == claimed group, add passenger_id to list
    [
      set passenger-ids lput passenger_id passenger-ids
    ]
  ]
  
  report passenger-ids ; list of passenger ids corresponding to claimed groups
end

; inform all buses about the passenger ids that are claimed
to communicate-claim 
  let claim claim-passenger-ids next_stop pick_up_passenger_group

  let id 0
  while [ id < buses_count ] [    
    if (id + length graph) != bus_id [
      send-message (id + length graph) (list "claim" claim)
    ]
    set id id + 1   
  ]
end



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; USEFUL DEBUG COMMANDS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;print matrix:dimensions score_matrix ; debug - checks matrix dimensions
  ;matrix:get matrix row-i col-j ;could be used to check scores of others, also see: matrix:get-row matrix row-i
  ;matrix:set matrix row-i col-j new-value ;fill the matrix with the score per person using this command
  ;show "Matrix update: "
  ;print matrix:pretty-print-text score_matrix  

  ;if current_stop != -1 
  ;[
  ; show (word "Passengers at current stop " current_stop ": " (get-passengers-at-stop current_stop))    
  ;]