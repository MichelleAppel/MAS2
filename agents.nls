extensions[matrix]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
  cost_per_patch  ; The cost per patch for this bus type
  capacity        ; The capacity of the bus
  
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).
  pick_up_passenger_group ; The passenger groups that the bus is going to pick up
  
  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  buses_count     ; The amount of other busses that exist
  message_protocol; The variable that is going to contain the message
  score_list      ; List that contains scores for every bus stop 
  buses_database

  ; TODO: check whether these can be local variables
  power-set
  new-sets
  subset
]
 
globals [graph]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Initialize and perform actions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initialize agents and variables  
  to init-buses
    
  calculate-power-set ; to show that it works
      
  set-cost-per-patch
  set-bus-capacity
  
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
    
  set buses_count bus_id - length graph + 1 ; Set current amount of busses
  send-initial-message ; Send message to all other existing busses to let know that a new bus exists
  set buses_database n-values buses_count [[]]
  
  calculate-scores ; Calculate score for connected bus stops
  set-next-stop ; Determine next bus stop (highest score)
 
end 

; Add decision making strategies for your agents here.
; You are allowed to use the global variable 'ticks'.
to execute-actions 
  
  
  read-inbox
  if current_stop != -1
  [
    calculate-scores
    
    ;show score_list
    
    set-next-stop
    ;show next_stop
    ;show pick_up_passenger_group
  ]
  
  travel-to next_stop
  drop-off-passengers  
  pick-up-passengers
  
   ;show inbox
   ;show buses_database
  send-initial-message
   ;show message_protocol ; debug
   ;show bus_passengers?
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Inbox ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Creates the message to be sent
to create-message
  set message_protocol (list "Bus type:" bus_type "Bus passengers:" bus_passengers "Previous stop: " previous_stop "Current stop: " current_stop "Next stop: " next_stop); ; Message protocol containing all variables that need sharing, strings added temporarily for readability
end

; Send message to other buses to let them know this bus exists
to send-initial-message 
  let id length graph 
  while [ id < bus_id ] [
   create-message
   send-message id message_protocol
   set id id + 1
  ]
end

; Read the inbox
to read-inbox
  foreach inbox [
   if item 1 ? - length graph + 1 > buses_count [ ; Check if message from new bus is received 
     set buses_count item 1 ? - length graph + 1  ; Updates buses_countn
   ]

   ifelse (item 1 ? - length graph + 1) > length(buses_database) [
    set buses_database lput ? buses_database
   ]
   [
   set buses_database replace-item (item 1 ? - length graph) buses_database ?
   ]
  ]
  set inbox []
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Route ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set the next stop according to score
to set-next-stop
  if next_stop = -1 [

    ifelse (max n-values length(score_list) [item 0 item ? score_list]) > 0 [
      foreach score_list
      [
        if item 0 ? = max n-values length(score_list) [item 0 item ? score_list]
        [
          set next_stop item 1 ?
          set pick_up_passenger_group item 2 ?
        ]
      ]
    ]
    [
      set next_stop one-of item current_stop graph ; Choose random connected bus stop
    ]
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Passenger actions (pick up/drop off) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Pick up every passenger at the stop until bus is full
to pick-up-passengers
  if current_stop != -1 ; Check if bus is currently at a stop 
  [
    foreach get-passengers-at-stop current_stop
    [
      if length bus_passengers < bus_type3_capacity ; If the bus is not full
      [
        if member? item 1 ? pick_up_passenger_group ; Pick up when in passenger group
        [
          pick-up-passenger item 0 ? ; Pick up the passenger
        ]
      ]
    ]
  ]
end

; Drop off every passenger that has arrived at its destination
to drop-off-passengers 
  if current_stop != -1 ; Check if bus is currently at a stop 
  [
    foreach bus_passengers
    [
      if item 1 ? = current_stop ; If a passenger is at its destination
      [
        drop-off-passenger item 0 ? ; Drop off
      ]
    ]
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Calculate Score ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to calculate-scores
  if current_stop != -1
  [
    let s0 ( list item current_stop xs item current_stop ys ) ; Current stop coordinates s0
    
    ; Weights of the route vector
    let passenger_group_count n-values length(graph) [ 0 ]
    foreach bus_passengers
    [ 
      set passenger_group_count replace-item (item 1 ?) passenger_group_count (item item 1 ? passenger_group_count + 1) 
    ]
    
    ; Estimated route vector r0 (weighted average of destination of passengers on board)
    let r0 ( list 0 0 ) 
    ifelse sum(passenger_group_count) > 0 ; If there are passengers on board
    [
      foreach n-values length(graph) [ ? ]
      [
        let xw item ? xs * item ? passenger_group_count
        let yw item ? ys * item ? passenger_group_count
        set r0 ( list (item 0 r0 + xw) (item 1 r0 + yw) )
      ]
      set r0 ( list (item 0 r0 / sum(passenger_group_count) ) (item 1 r0 / sum(passenger_group_count) ) )
    ]
    [
      set r0 s0 ; If there are no passengers on board set the estimated route equal to the current stop
    ]
    
    let scores []

    foreach (item current_stop graph) ; Get possible next stops
    [
      let stop_number ?
      let s1 ( list item ? xs item ? ys ) ; Next stop coordinates s1
      
      ; Weights of the route vector r1
      let passenger_group_count_s1 n-values length(graph) [ 0 ]
          foreach get-passengers-at-stop ?
          [ 
            set passenger_group_count_s1 replace-item (item 1 ?) passenger_group_count_s1 (item item 1 ? passenger_group_count_s1 + 1) 
          ]
          
      ; Passenger groups of s1
      let passenger_groups []
      foreach n-values length(graph) [ ? ]
      [
        if item ? passenger_group_count_s1 > 0 ; If passenger with destination ?
        [
          set passenger_groups lput (list (?) (item ? passenger_group_count_s1) ) passenger_groups ; Destination, count
        ]
      ]
      
      let powerset []
      foreach passenger_groups
      [
        set powerset lput ( list ? ) powerset ; TODO: Make powerset of all possible passenger group combinations
      ]
      set powerset lput passenger_groups powerset ; Currently only single groups and all together
      
      let scoresr1 []
      foreach powerset
      [
        let r1 ( list 0 0 )
        let counter 0
        foreach ?
        [
          let xw item item 0 ? xs * item 1 ?
          let yw item item 0 ? ys * item 1 ?
          set r1 ( list (item 0 r0 + xw) (item 1 r0 + yw) )
          set counter counter + item 1 ?
        ]
        ifelse counter > 0
        [
        set r1 ( list (item 0 r1 / counter ) (item 1 r1 / counter ) )
        ]
        [
          set r1 s1
        ]
        
        
        let drop_off_count item stop_number passenger_group_count
        let pick_up_count counter
        if capacity - length(bus_passengers) < counter - drop_off_count
        [
          set pick_up_count capacity - length(bus_passengers) + drop_off_count
        ] 
        show pick_up_count
        
        let vs0s1 ( list (item 0 s1 - item 0 s0 ) (item 1 s1 - item 1 s0 ) )
        let vs0r0 ( list (item 0 r0 - item 0 s0 ) (item 1 r0 - item 1 s0 ) )
        let vs1r0 ( list (item 0 r0 - item 0 s1 ) (item 1 r0 - item 1 s1 ) )
        let vs1r1 ( list (item 0 r1 - item 0 s1 ) (item 1 r1 - item 1 s1 ) )
        
        let vs0s1*vs0s1 ( item 0 vs0s1 * item 0 vs0r0 ) + ( item 1 vs0s1 * item 1 vs0r0 )
        let vs1r0*vs1r1 ( item 0 vs1r0 * item 0 vs1r1 ) + ( item 1 vs1r0 * item 1 vs1r1 )
        
        let len_vs0s1 sqrt( (item 0 vs0s1) ^ 2 + (item 1 vs0s1) ^ 2 ) + 1
        let len_vs1r1 sqrt( (item 0 vs1r1) ^ 2 + (item 1 vs1r1) ^ 2 ) + 1
        
        let scorer1 (1 / cost_per_patch) * ( 1 + drop_off_count ) * ln( 1 + exp(vs0s1*vs0s1 / len_vs0s1 ) ) + ( 1 + pick_up_count ) * ln( 1 + exp(vs1r0*vs1r1 / len_vs1r1 ) )
        
        set scoresr1 lput scorer1 scoresr1
      ]
      
      let maximum max scoresr1
      let argmax position max scoresr1 scoresr1
      
      let pickup_groups []
      foreach item argmax powerset
      [
        set pickup_groups lput item 0 ? pickup_groups
      ]
      
      set scores lput ( list maximum stop_number pickup_groups ) scores
    ]
    set score_list scores
  ]
end


to set-cost-per-patch
  if bus_type = 1
  [set cost_per_patch bus_type1_cost_per_patch]
  if bus_type = 2
  [set cost_per_patch bus_type2_cost_per_patch]
  if bus_type = 3
  [set cost_per_patch bus_type3_cost_per_patch]
end

to set-bus-capacity
  if bus_type = 1
  [set capacity bus_type1_capacity]
  if bus_type = 2
  [set capacity bus_type2_capacity]
  if bus_type = 3
  [set capacity bus_type3_capacity]
end

; TODO: instead of three random numbers, use real data
; TODO: if possible, make code shorter 
to calculate-power-set
  let passenger-groups (list random 24 random 24 random 24) ; list of passenger groups (min: empty list, max: 24 integers)
  write "Passenger groups"
  show passenger-groups
  set power-set [[]] ; init with empty list
  
  foreach passenger-groups ; loop through all passenger groups
  [
   let pass-group ?
   set new-sets []
   foreach power-set ; loop through all current power sets
   [
     set subset ?
     ; if current power set does not contain current passenger group, add it
     if not member? pass-group subset [
        set subset lput pass-group subset
     ]
     
     if not member? subset new-sets [
       set new-sets lput subset new-sets
     ]
   ]

   foreach new-sets ; add new sets to current power set (no built-in function for 'extend')
   [
     set power-set lput ? power-set
   ]

  ]
  
set power-set remove-duplicates power-set ; remove duplicates

write "Power set"
show power-set

end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; USEFUL DEBUG COMMANDS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;print matrix:dimensions score_matrix ; debug - checks matrix dimensions
  ;matrix:get matrix row-i col-j ;could be used to check scores of others, also see: matrix:get-row matrix row-i
  ;matrix:set matrix row-i col-j new-value ;fill the matrix with the score per person using this command
  ;show "Matrix update: "
  ;print matrix:pretty-print-text score_matrix  

  ;if current_stop != -1 
  ;[
  ; show (word "Passengers at current stop " current_stop ": " (get-passengers-at-stop current_stop))    
  ;]