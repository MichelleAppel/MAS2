extensions[matrix]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
  cost_per_patch  ; The cost per patch for this bus type
  capacity        ; The capacity of the bus
  
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).
  pick_up_passenger_group ; The passenger groups that the bus is going to pick up
  
  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  buses_count     ; The amount of other busses that exist
  message_protocol; The variable that is going to contain the message
  score_list      ; List that contains scores for every bus stop 
  buses_database
  
  maximum-score-busstop ; the maximum score and the next busstop, which will be sent to all buses
  
  tree-score     ; Ugly variables because netlogo doesn't allow recursive report functions rip
  tree-group     ;
]
 
globals [graph]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Initialize and perform actions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initialize agents and variables  
to init-buses

  set-cost-per-patch
  set-bus-capacity
  
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
    
  set buses_count bus_id - length graph + 1 ; Set current amount of busses
  send-initial-message ; Send message to all other existing busses to let know that a new bus exists
  set buses_database n-values buses_count [[]]
  
  calculate-scores ; Calculate score for connected bus stops
  set-next-stop ; Determine next bus stop (highest score)
  
  
  set maximum-score-busstop []
 
end 

; Add decision making strategies for your agents here.
; You are allowed to use the global variable 'ticks'.
to execute-actions 
  
  read-inbox

  if current_stop != -1
  [
    calculate-scores    
    set-next-stop
    ;show next_stop
    ;show pick_up_passenger_group
  ]
  
  travel-to next_stop
  drop-off-passengers  
  pick-up-passengers
  
      ;show inbox
      ;show buses_database
  send-initial-message
      ;show message_protocol ; debug
      ;show bus_passengers?
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Inbox ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Creates the message to be sent
to create-message
  set message_protocol (list "Bus type:" bus_type "Bus passengers:" bus_passengers "Previous stop: " previous_stop "Current stop: " current_stop "Next stop: " next_stop); ; Message protocol containing all variables that need sharing, strings added temporarily for readability
end

; Send message to other buses to let them know this bus exists
to send-initial-message 
  let id length graph 
  while [ id < bus_id ] [
   create-message
   send-message id message_protocol
   set id id + 1
  ]
end

; Read the inbox
to read-inbox
  foreach inbox [
    ;show ?
    
   if item 1 ? - length graph + 1 > buses_count [ ; Check if message from new bus is received 
     set buses_count item 1 ? - length graph + 1  ; Updates buses_count
   ]

   ifelse (item 1 ? - length graph + 1) > length(buses_database) [
    set buses_database lput ? buses_database
   ]
   [
   set buses_database replace-item (item 1 ? - length graph) buses_database ?
   ]
  ]
  set inbox []
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Route ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set the next stop according to score
to set-next-stop
  if next_stop = -1 [

    ifelse (max n-values length(score_list) [item 0 item ? score_list]) > 0 [
      foreach score_list
      [
        if item 0 ? = max n-values length(score_list) [item 0 item ? score_list]
        [
          set next_stop item 1 ?
          set pick_up_passenger_group item 2 ?
        ]
      ]
    ]
    [
      set next_stop one-of item current_stop graph ; Choose random connected bus stop
    ]
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Passenger actions (pick up/drop off) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Pick up every passenger at the stop until bus is full
to pick-up-passengers
  if current_stop != -1 ; Check if bus is currently at a stop 
  [
    foreach get-passengers-at-stop current_stop
    [
      if length bus_passengers < bus_type3_capacity ; If the bus is not full
      [
        if member? item 1 ? pick_up_passenger_group ; Pick up when in passenger group
        [
          pick-up-passenger item 0 ? ; Pick up the passenger
        ]
      ]
    ]
  ]
end

; Drop off every passenger that has arrived at its destination
to drop-off-passengers 
  if current_stop != -1 ; Check if bus is currently at a stop 
  [
    foreach bus_passengers
    [
      if item 1 ? = current_stop ; If a passenger is at its destination
      [
        drop-off-passenger item 0 ? ; Drop off
      ]
    ]
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Calculate Score ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to calculate-scores
  set maximum-score-busstop []
  
  if current_stop != -1
  [
    let s0 ( list item current_stop xs item current_stop ys ) ; Current stop coordinates s0
    
    ; Weights of the route vector
    let passenger_group_count n-values length(graph) [ 0 ]
    foreach bus_passengers
    [ 
      set passenger_group_count replace-item (item 1 ?) passenger_group_count (item item 1 ? passenger_group_count + 1) 
    ]

    ; Estimated route vector r0 (weighted average of destination of passengers on board)
    let r0 ( list 0 0 ) 
    ifelse sum(passenger_group_count) > 0 ; If there are passengers on board
    [
      foreach n-values length(graph) [ ? ]
      [
        let xw item ? xs * item ? passenger_group_count
        let yw item ? ys * item ? passenger_group_count
        set r0 ( list (item 0 r0 + xw) (item 1 r0 + yw) )
      ]
      set r0 ( list (item 0 r0 / sum(passenger_group_count) ) (item 1 r0 / sum(passenger_group_count) ) )
    ]
    [
      set r0 s0 ; If there are no passengers on board set the estimated route equal to the current stop
    ]
    
    let scores []

    foreach (item current_stop graph) ; Get possible next stops
    [
      let stop_number ?
      let s1 ( list item ? xs item ? ys ) ; Next stop coordinates s1
      
      ; Weights of the route vector r1
      let passenger_group_count_s1 n-values length(graph) [ 0 ]
          foreach get-passengers-at-stop ?
          [ 
            set passenger_group_count_s1 replace-item (item 1 ?) passenger_group_count_s1 (item item 1 ? passenger_group_count_s1 + 1) 
          ]
          
      ; Passenger groups of s1
      let passenger_groups []
      foreach n-values length(graph) [ ? ]
      [
        if item ? passenger_group_count_s1 > 0 ; If passenger with destination ?
        [
          set passenger_groups lput (list (?) (item ? passenger_group_count_s1) ) passenger_groups ; Destination, count
        ]
      ]
      
      let scoresr1 []
      let powerset []  
       
       
      ifelse length passenger_groups < 10 ; Pick acceptable treshold
      [
        set powerset calculate-power-set passenger_groups

        foreach powerset
        [
          let r1 ( list 0 0 )
          let counter 0
          foreach ?
          [
            let xw item item 0 ? xs * item 1 ?
            let yw item item 0 ? ys * item 1 ?
            set r1 ( list ( item 0 r0 + xw ) ( item 1 r0 + yw ) )
            set counter counter + item 1 ?
          ]
          ifelse counter > 0
          [
            set r1 ( list ( item 0 r1 / counter ) ( item 1 r1 / counter ) )
          ]
          [
            set r1 s1
          ]
          
          let drop_off_count item stop_number passenger_group_count
          let pick_up_count counter
          if capacity - length(bus_passengers) < counter - drop_off_count
          [
            set pick_up_count capacity - length(bus_passengers) + drop_off_count
          ] 
          
          let vs0s1 ( list ( item 0 s1 - item 0 s0 ) ( item 1 s1 - item 1 s0 ) )
          let vs0r0 ( list ( item 0 r0 - item 0 s0 ) ( item 1 r0 - item 1 s0 ) )
          let vs1r0 ( list ( item 0 r0 - item 0 s1 ) ( item 1 r0 - item 1 s1 ) )
          let vs1r1 ( list ( item 0 r1 - item 0 s1 ) ( item 1 r1 - item 1 s1 ) )
          if pick_up_count < 1
          [
            set vs1r1 vs1r0
          ]
          
          
          let vs0s1*vs0r0 ( item 0 vs0s1 * item 0 vs0r0 ) + ( item 1 vs0s1 * item 1 vs0r0 )
          let vs1r0*vs1r1 ( item 0 vs1r0 * item 0 vs1r1 ) + ( item 1 vs1r0 * item 1 vs1r1 )
          
          let len_vs0s1 sqrt( (item 0 vs0s1) ^ 2 + (item 1 vs0s1) ^ 2 ) + 1
          let len_vs1r1 sqrt( (item 0 vs1r1) ^ 2 + (item 1 vs1r1) ^ 2 ) + 1
          let len_vs0r0 sqrt( (item 0 vs0r0) ^ 2 + (item 1 vs0r0) ^ 2 ) + 1
          let len_vs1r0 sqrt( (item 0 vs1r0) ^ 2 + (item 1 vs1r0) ^ 2 ) + 1
          
          let scorer1 ( 1 / cost_per_patch ) * ( 1 + drop_off_count ) * ln( 1 + exp( vs0s1*vs0r0 / len_vs0s1 ^ 2 ) ) + ( 1 + pick_up_count ) * ln( 1 + exp( vs1r0*vs1r1 / len_vs1r1 ^ 2 ) )
          
          set scoresr1 lput scorer1 scoresr1
        ]
      ]
      [ ; If more then 10 passenger groups
        show length passenger_groups
        
        let single_groups []
        
        foreach passenger_groups
        [
          set single_groups lput ( list ? ) single_groups
        ]

        score-tree-search single_groups stop_number
        show tree-score
        show tree-group
        
        set scoresr1 lput item 0 tree-score scoresr1
        set powerset tree-group
      ]
      

        let maximum max scoresr1
        let argmax position max scoresr1 scoresr1
        let pickup_groups []
        
        foreach item argmax powerset
        [
          ifelse length(?) > 0
          [
            set pickup_groups lput item 0 ? pickup_groups
          ]
          [
            set pickup_groups lput [] pickup_groups
          ]
        ]
        set scores lput ( list maximum stop_number pickup_groups ) scores
      

      
      ; set maximum score, along with busstop and passenger group, to communicate with other buses
      ifelse length(maximum-score-busstop) = 0
      [
        set maximum-score-busstop ( list maximum stop_number pickup_groups )
      ]
      [
        if maximum > item 0 maximum-score-busstop
        [
          set maximum-score-busstop ( list maximum stop_number pickup_groups )
          ;print "New maximum score"
          ;show maximum-score-busstop
        ]
      ]
    ]
    set score_list scores
  ]
end



; Set the travelling cost per patch of the current bus
to set-cost-per-patch
  if bus_type = 1
  [set cost_per_patch bus_type1_cost_per_patch]
  if bus_type = 2
  [set cost_per_patch bus_type2_cost_per_patch]
  if bus_type = 3
  [set cost_per_patch bus_type3_cost_per_patch]
end

; Set the passenger capacity of the current bus
to set-bus-capacity
  if bus_type = 1
  [set capacity bus_type1_capacity]
  if bus_type = 2
  [set capacity bus_type2_capacity]
  if bus_type = 3
  [set capacity bus_type3_capacity]
end

; Calculate the power set of a list of passenger-groups, containg integers ranging from 0-23
to-report calculate-power-set [ passenger-groups ]
  let power-set [[]] ; init with empty list
  
  foreach passenger-groups ; loop through all passenger groups
  [
   let pass-group ? ; an element of passenger-group
   let new-sets [] ; init new sets to be added to the power set
   foreach power-set ; loop through all current power sets
   [
     let subset ? ; an element of power-set
     ; if current power set does not contain current passenger group, add it
     if not member? pass-group subset [
        set subset lput pass-group subset
     ]
     
     ; if current (new) set does not contain current power set, add it
     if not member? subset new-sets [
       set new-sets lput subset new-sets
     ]
   ]

   foreach new-sets ; add new sets to current power set (no built-in function for 'extend')
   [
     set power-set lput ? power-set
   ]
  ]
  
set power-set remove-duplicates power-set ; remove duplicates
report power-set ; return the local variable
end



to score-tree-search [ passenger_groups stop_number ]
  let scoresr1 []
  
  ifelse length passenger_groups > 1
  [
    foreach passenger_groups
    [
      let scorer1 score (list ?) stop_number
      set scoresr1 lput item 0 scorer1 scoresr1
    ]  
    
    let maximum_group item position max scoresr1 scoresr1 passenger_groups
    
    set passenger_groups remove-item position maximum_group passenger_groups passenger_groups
    
    foreach passenger_groups
    [
      set passenger_groups replace-item position ? passenger_groups passenger_groups lput item 0 maximum_group ?
    ]
    
    score-tree-search passenger_groups stop_number
  ]
  [
  set tree-score score passenger_groups stop_number
  set tree-group passenger_groups
  ]
end


to-report score [ passenger_groups stop_number ]
  let scoresr1 []
  if current_stop != -1
  [
    let s0 ( list item current_stop xs item current_stop ys ) ; Current stop coordinates s0
    
    ; Weights of the route vector
    let passenger_group_count n-values length(graph) [ 0 ]
    foreach bus_passengers
    [ 
      set passenger_group_count replace-item (item 1 ?) passenger_group_count (item item 1 ? passenger_group_count + 1) 
    ]

    ; Estimated route vector r0 (weighted average of destination of passengers on board)
    let r0 ( list 0 0 ) 
    ifelse sum(passenger_group_count) > 0 ; If there are passengers on board
    [
      foreach n-values length(graph) [ ? ]
      [
        let xw item ? xs * item ? passenger_group_count
        let yw item ? ys * item ? passenger_group_count
        set r0 ( list (item 0 r0 + xw) (item 1 r0 + yw) )
      ]
      set r0 ( list (item 0 r0 / sum(passenger_group_count) ) (item 1 r0 / sum(passenger_group_count) ) )
    ]
    [
      set r0 s0 ; If there are no passengers on board set the estimated route equal to the current stop
    ]
    
    let scores []

    let s1 ( list item stop_number xs item stop_number ys ) ; Next stop coordinates s1
    

    foreach passenger_groups
    [
      let r1 ( list 0 0 )
      let counter 0
      foreach ?
      [
        let xw item item 0 ? xs * item 1 ?
        let yw item item 0 ? ys * item 1 ?
        set r1 ( list (item 0 r0 + xw) (item 1 r0 + yw) )
        set counter counter + item 1 ?
      ]
      ifelse counter > 0
      [
      set r1 ( list (item 0 r1 / counter ) (item 1 r1 / counter ) )
      ]
      [
        set r1 s1
      ]
      
      let drop_off_count item stop_number passenger_group_count
      let pick_up_count counter
      if capacity - length(bus_passengers) < counter - drop_off_count
      [
        set pick_up_count capacity - length(bus_passengers) + drop_off_count
      ] 
      
      let vs0s1 ( list (item 0 s1 - item 0 s0 ) (item 1 s1 - item 1 s0 ) )
      let vs0r0 ( list (item 0 r0 - item 0 s0 ) (item 1 r0 - item 1 s0 ) )
      let vs1r0 ( list (item 0 r0 - item 0 s1 ) (item 1 r0 - item 1 s1 ) )
      let vs1r1 ( list (item 0 r1 - item 0 s1 ) (item 1 r1 - item 1 s1 ) )
      if pick_up_count < 1
      [
        set vs1r1 vs1r0
      ]
      
      
      let vs0s1*vs0r0 ( item 0 vs0s1 * item 0 vs0r0 ) + ( item 1 vs0s1 * item 1 vs0r0 )
      let vs1r0*vs1r1 ( item 0 vs1r0 * item 0 vs1r1 ) + ( item 1 vs1r0 * item 1 vs1r1 )
      
      let len_vs0s1 sqrt( (item 0 vs0s1) ^ 2 + (item 1 vs0s1) ^ 2 ) + 1
      let len_vs1r1 sqrt( (item 0 vs1r1) ^ 2 + (item 1 vs1r1) ^ 2 ) + 1
      let len_vs0r0 sqrt( (item 0 vs0r0) ^ 2 + (item 1 vs0r0) ^ 2 ) + 1
      let len_vs1r0 sqrt( (item 0 vs1r0) ^ 2 + (item 1 vs1r0) ^ 2 ) + 1
      
      let scorer1 (1 / cost_per_patch) * ( 1 + drop_off_count ) * ln( 1 + exp( vs0s1*vs0r0 / len_vs0s1 ^ 2 ) ) + ( 1 + pick_up_count ) * ln( 1 + exp( vs1r0*vs1r1 / len_vs1r1 ^ 2 ) )
      
      set scoresr1 lput scorer1 scoresr1
    ]
  ]
  report scoresr1
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; USEFUL DEBUG COMMANDS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;print matrix:dimensions score_matrix ; debug - checks matrix dimensions
  ;matrix:get matrix row-i col-j ;could be used to check scores of others, also see: matrix:get-row matrix row-i
  ;matrix:set matrix row-i col-j new-value ;fill the matrix with the score per person using this command
  ;show "Matrix update: "
  ;print matrix:pretty-print-text score_matrix  

  ;if current_stop != -1 
  ;[
  ; show (word "Passengers at current stop " current_stop ": " (get-passengers-at-stop current_stop))    
  ;]