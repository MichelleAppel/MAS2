; TODO: improve score function: weights of r0 should be inversely proportional to the distance s0r0
extensions[matrix]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
  cost_per_patch  ; The cost per patch for this bus type
  capacity        ; The capacity of the bus
  
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).
  
  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  buses_count     ; The amount of other busses that exist
  message_protocol; The variable that is going to contain the message
  score_list      ; List that contains scores for every bus stop 
  buses_database
      
  pick_up_passenger_group ; The passenger groups that the bus is going to pick up

  max_score
  wait_counter     ; simple shared tick counter used between functions
  maximum-score-busstop ; the maximum score and the next busstop, which will be sent to all buses
  second_choice   ; boolean indicating to go for the first or second choice

  tree-score     ; Ugly variables because netlogo doesn't allow recursive report functions rip
  tree-group     ;
  
  claimed_passengers ; list of claimed passenger_ids
]
 
globals [graph]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Initialize and perform actions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initialize agents and variables  
to init-buses

  set-cost-per-patch
  set-bus-capacity
  set wait_counter 0
  set second_choice false
  
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
    
  set buses_count bus_id - length graph + 1 ; Set current amount of busses
  send-initial-message ; Send message to all other existing busses to let know that a new bus exists
  set buses_database n-values buses_count [[]]
  
  calculate-scores ; Calculate score for connected bus stops
  set-next-stop ; Determine next bus stop (highest score)
  
  set maximum-score-busstop []
  
  set claimed_passengers []
 
end 

; Add decision making strategies for your agents here.
; You are allowed to use the global variable 'ticks'.
to execute-actions 
  read-inbox
  
  ifelse wait_counter > 0 
   [
     set wait_counter wait_counter - 1
     show "wait counter from loop: "
     show wait_counter  
   ]
   [
   if current_stop != -1 ; If the bus is at a bus stop
    [     
     calculate-scores
     request-score
     set-next-stop
     communicate-claim
     ;show next_stop
     ;show pick_up_passenger_group
     ;show score_list
    ] 
   travel-to-stop
   drop-off-passengers
   pick-up-passengers
   ]

      ;show buses_database
  send-initial-message
      ;show message_protocol ; debug
      ;show bus_passengers?
      
      
;  write "BUS_ID"
;  show bus_id
;  write "CLAIM_LIST"
;  show claimed_passengers
    
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Inbox ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Creates the message to be sent
to create-message
  set message_protocol (list "Bus type:" bus_type "Bus passengers:" bus_passengers "Previous stop: " previous_stop "Current stop: " current_stop "Next stop: " next_stop); ; Message protocol containing all variables that need sharing, strings added temporarily for readability
end

; Send message to other buses to let them know this bus exists
to send-initial-message 
  let id length graph 
  while [ id < bus_id ] [
   create-message
   send-message id message_protocol
   set id id + 1
  ]
end

; Read the inbox
to read-inbox
  
  foreach inbox [
    
; If a request for score is received, calculate score and send this back if it's higher
   if member? "request" item 2 ? [
     show "I received a score request!"
     let templist(item 2 ?)
     show "Bus stop number sent by the requestee: "
     show item 1 item 1 templist ; returns the bus stop number sent by the requestee 
     ; todo calculate scores for specific bus stop     
     let requested-score (list 8.14 16 [1 7]) ; static for now because I'm not sure how to calculate scores for one specific bus stop (item 1 item 1 templist)     
     show templist
     if (item 0 requested-score) > item 0 item 1 templist [ ; Compare newly calculated score with the score of the bus that asked for it
       send-message (item 1 ?) (list "response" requested-score) ;Send a message back to the bus with the requested score
       show "Sent a message back to bus#: "
       show (item 1 ?)
       ]     
     ]
 
; If we received a response  
   if member? "response" item 2 ? [
     show "I received a response!"
     set second_choice true;
     ; Go for second choice
     ; Else go for first choice
     ]
   
; If we received a claim  
   if member? "claim" item 2 ? [
     let claims item 1 item 2 ?
     foreach claims ; add to existing claim list
     [
       set claimed_passengers lput ? claimed_passengers
     ]
   ]
   
   
   if item 1 ? - length graph + 1 > buses_count [ ; Check if message from new bus is received 
     set buses_count item 1 ? - length graph + 1  ; Updates buses_count
   ]

   ifelse (item 1 ? - length graph + 1) > length(buses_database) [
    set buses_database lput ? buses_database
   ]
   [
   set buses_database replace-item (item 1 ? - length graph) buses_database ?
   ]
  ]
  set inbox []
end

to request-score
  ifelse wait_counter = 0 
  [
    set wait_counter -1
  ]
  [
    ;calc max score
    foreach score_list
    [
      if item 0 ? = max n-values length(score_list) [item 0 item ? score_list]
      [
        set max_score(list item 0 ? item 1 ? item 2 ?)
      ]
    ]
    ;send message to all other buses    
    let id 0
    while [ id < buses_count ] [    
      if (id + length graph) != bus_id [
        send-message (id + length graph) (list "request" max_score)
        show "List 'request' max_score, from request-score function: "
        show (list "request" max_score)
        set wait_counter 1 ; Set a wait counter 
        ]
      set id id + 1   
    ]
  ]  
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Route ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set the next stop according to score
to set-next-stop

  ifelse second_choice = false  
  [
     if (max n-values length(score_list) [item 0 item ? score_list]) > 0 [
       foreach score_list
       [
         if item 0 ? = max n-values length(score_list) [item 0 item ? score_list]
         [
           set next_stop item 1 ?
           show "just set next stop (second_choice =false): "
           show next_stop
           set pick_up_passenger_group item 2 ?
         ]
       ]
     ]
   ]
   [
     show "Other bus with higher score detected, going for second choice"
     foreach score_list
     [    
       if item 0 ? = max n-values length(score_list) [item 0 item ? score_list]
       [
         show "Score_list_length: "
         ifelse length(score_list) > 1 [
         show "length > 1"
         let pos position (item 0 ?) map first score_list
         let temp_list remove-item pos score_list ;remove-item index list replace 0 with location of MAX  (item 0 ?) = VALUE of max.
         foreach temp_list
         [
          if item 0 ? = max n-values length(temp_list) [item 0 item ? temp_list]
          [
            set next_stop item 1 ? 
            show "just set next stop (second_choice =true): "
            show next_stop            
            set pick_up_passenger_group item 2 ?
          ] 
         ]
         ] 
         [
           show "length < 1"
           set next_stop item 1 ?
         ]
       ]
     ]
     set second_choice false                         
   ]
end

to travel-to-stop
  if (wait_counter = 0) or (wait_counter = -1)
  [
    travel-to next_stop
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Passenger actions (pick up/drop off) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Pick up every passenger at the stop until bus is full
to pick-up-passengers
  if current_stop != -1 ; Check if bus is currently at a stop 
  [
    foreach get-passengers-at-stop current_stop
    [
      if length bus_passengers < bus_type3_capacity ; If the bus is not full
      [
        if member? item 1 ? pick_up_passenger_group ; Pick up when in passenger group
        [
          pick-up-passenger item 0 ? ; Pick up the passenger
        ]
      ]
    ]
  ]
end

; Drop off every passenger that has arrived at its destination
to drop-off-passengers 
  if current_stop != -1 ; Check if bus is currently at a stop 
  [
    foreach bus_passengers
    [
      if item 1 ? = current_stop ; If a passenger is at its destination
      [
        drop-off-passenger item 0 ? ; Drop off
      ]
    ]
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Calculate Score ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to calculate-scores
  set maximum-score-busstop []
  let scores []
  
  if current_stop != -1
  [
    foreach (item current_stop graph) ; Get possible next stops
    [
      let stop0_id current_stop
      let stop1_id ?

      let passenger_groups0_count passenger-count bus_passengers
      let passenger_groups0 passenger-group passenger_groups0_count
      
      let passenger_groups1_count passenger-count get-passengers-at-stop stop1_id
      let passenger_groups1 passenger-group passenger_groups1_count

      let scoresr1 [] ; All scores for stop1
      let passenger_group_combinations [] ; 
       
      ifelse length passenger_groups1 < 10 ; Pick acceptable treshold to prevent blowup
      [
        set passenger_group_combinations calculate-power-set passenger_groups1 ; Powerset of all groups

        foreach passenger_group_combinations
        [
          let passenger_groups1_subset ? ; Subset of the passenger groups

          let scorer1 score stop0_id stop1_id passenger_groups0 passenger_groups1_subset ; Compute score for passenger group subset
          
          set scoresr1 lput scorer1 scoresr1 ; Append score to score list for this stop
        ]
      ]
      
      [ ; If more then 10 passenger groups        
        let scorer1_group_list score-tree-search stop0_id stop1_id passenger_groups0 passenger_groups1
        
        set scoresr1 ( list item 0 scorer1_group_list )
        set passenger_group_combinations ( list item 1 scorer1_group_list )
      ]
      

        let maximum max scoresr1
        let argmax position max scoresr1 scoresr1
        let pickup_groups []
        
        foreach item argmax passenger_group_combinations
        [
          ifelse length(?) > 0
          [
            set pickup_groups lput item 0 ? pickup_groups
          ]
          [
            set pickup_groups lput [] pickup_groups
          ]
        ]
        
        set scores lput ( list maximum stop1_id pickup_groups ) scores
      
      ; set maximum score, along with busstop and passenger group, to communicate with other buses
      ifelse length(maximum-score-busstop) = 0
      [
        set maximum-score-busstop ( list maximum stop1_id pickup_groups )
      ]
      [
        if maximum > item 0 maximum-score-busstop
        [
          set maximum-score-busstop ( list maximum stop1_id pickup_groups )
          ;print "New maximum score"
          ;show maximum-score-busstop
        ]
      ]
    ]
    set score_list scores
    show "Score_list: "
    show score_list
  ]
end



; Set the travelling cost per patch of the current bus
to set-cost-per-patch
  if bus_type = 1
  [set cost_per_patch bus_type1_cost_per_patch]
  if bus_type = 2
  [set cost_per_patch bus_type2_cost_per_patch]
  if bus_type = 3
  [set cost_per_patch bus_type3_cost_per_patch]
end

; Set the passenger capacity of the current bus
to set-bus-capacity
  if bus_type = 1
  [set capacity bus_type1_capacity]
  if bus_type = 2
  [set capacity bus_type2_capacity]
  if bus_type = 3
  [set capacity bus_type3_capacity]
end


; Calculate the power set of a list of passenger-groups, containg integers ranging from 0-23
to-report calculate-power-set [ passenger-groups ]
  let power-set [[]] ; init with empty list
  
  foreach passenger-groups ; loop through all passenger groups
  [
   let pass-group ? ; an element of passenger-group
   let new-sets [] ; init new sets to be added to the power set
   foreach power-set ; loop through all current power sets
   [
     let subset ? ; an element of power-set
     ; if current power set does not contain current passenger group, add it
     if not member? pass-group subset [
        set subset lput pass-group subset
     ]
     
     ; if current (new) set does not contain current power set, add it
     if not member? subset new-sets [
       set new-sets lput subset new-sets
     ]
   ]

   foreach new-sets ; add new sets to current power set (no built-in function for 'extend')
   [
     set power-set lput ? power-set
   ]
  ]
  
set power-set remove-duplicates power-set ; remove duplicates
report power-set ; return the local variable
end



to-report score-tree-search [ stop0_id stop1_id passenger_groups0 passenger_groups1 ]
  
  let maximum_score 0
  let maximum_scoring_group_subset []
  
  let single_groups []
  foreach passenger_groups1 ; Make list with single groups
  [ 
    let passenger_group ?         
    set single_groups lput ( list passenger_group ) single_groups
  ]
  
  let passenger_groups1_subset single_groups
  
  while [ length passenger_groups1_subset > 1 ] ; While not end of the tree
  [
    let scoresr1 []
    foreach passenger_groups1_subset
    [
      let passenger_group1_subset ?
      
      let scorer1 score stop0_id stop1_id passenger_groups0 passenger_group1_subset
      
      set scoresr1 lput scorer1 scoresr1 ; Add score to list
    ]  
    
    let maximum_scorer1 max scoresr1 ; The maximum score
    let maximum_scoring_group_index position maximum_scorer1 scoresr1 ; The index of this maximum score
    let maximum_scoring_group item maximum_scoring_group_index passenger_groups1_subset ; The corresponding group
    
    set passenger_groups1_subset remove-item maximum_scoring_group_index passenger_groups1_subset ; Remove group from list
    
    foreach passenger_groups1_subset
    [
      let passenger_group1_subset ?
      let current_index position passenger_group1_subset passenger_groups1_subset
      let new_passenger_group1 lput item 0 maximum_scoring_group passenger_group1_subset
      
      set passenger_groups1_subset replace-item current_index passenger_groups1_subset new_passenger_group1
    ]
    
     if maximum_scorer1 > maximum_score
     [
       set maximum_score maximum_scorer1
       set maximum_scoring_group_subset maximum_scoring_group
     ]
  ]
  
  report ( list maximum_score maximum_scoring_group_subset )
  
end



to-report passenger-count [ passengers_list ]
  let passenger_count n-values length(graph) [ 0 ] ; Make initial list of zeros for every possible destination
  
  foreach passengers_list
  [
    let passenger ?
    let destination_id item 1 passenger
    let group_count item destination_id passenger_count + 1 ; Increment current count
    
    set passenger_count replace-item destination_id passenger_count group_count
  ]
  
  report passenger_count
end


to-report passenger-group [ passenger_count ]
  let bus_passenger_groups [] ; Initial empty list
  
  let destination_id 0
  foreach passenger_count
  [
    let group_count ?
    
    if group_count > 0
    [
      set bus_passenger_groups lput ( list destination_id group_count ) bus_passenger_groups
    ]
    
    set destination_id destination_id + 1 ; Increment destination id
  ]
  
  report bus_passenger_groups
end


; Compute the score of travelling from stop0 to stop1 and picking up passenger_groups1 given
; passenger_groups0 on board of the bus

; Stop0             : Current stop number
; Stop1             : Next stop number
; Passenger_groups0 : The passenger groups on board of the bus [ [destination_id group_size] [destination_id group_size] ... ]
; Passenger_groups1 : The passenger groups to be picked up     [ [destination_id group_size] [destination_id group_size] ... ]

to-report score [ stop0_id stop1_id passenger_groups0 passenger_groups1 ]
  ifelse stop0_id != -1 and stop1_id != -1 ; Make sure stop0 and stop1 are valid stop ids
  [
    let s0 ( list item current_stop xs item current_stop ys ) ; Current stop coordinates s0
    
    
    ; Estimated route vector r0 (weighted average of destination of passengers on board)
    let r0 ( list 0 0 )       ; Initialize r0 vector

    let drop_off_count 0
    let passenger_groups0_count 0
    
    ifelse length passenger_groups0 > 0 ; If there are passengers on board
    [
      foreach passenger_groups0 ; For every passenger group in the bus
      [ 
        let passenger_group0 ?  ; The passenger group [destination_id group_size]
        
        let destination_id item 0 passenger_group0 ; The destination of the passenger group
        let group_size     item 1 passenger_group0 ; The group size
        
        let xw item destination_id xs * group_size ; x coordinate of the destination bus stop times the amount of passengers
        let yw item destination_id ys * group_size ; y coordinate of the destination bus stop times the amount of passengers
        
        set r0 ( list ( item 0 r0 + xw ) ( item 1 r0 + yw ) ) ; Increment r0 vector
        set passenger_groups0_count passenger_groups0_count + group_size
        if destination_id = stop1_id
        [
          set drop_off_count drop_off_count + group_size
        ]
      ]
      set r0 ( list (item 0 r0 / passenger_groups0_count ) (item 1 r0 / passenger_groups0_count ) ) ; Normalize with respect to the total amount of passengers in group0
    ]
    [
      set r0 s0 ; If there are no passengers on board set the estimated route equal to the current stop
    ]
    

    let s1 ( list item stop1_id xs item stop1_id ys ) ; Next stop coordinates s1
    
    ; Estimated route vector r1 (weighted average of destination of passengers on board)
    let r1 ( list 0 0 )       ; Initialize r1 vector

    let passenger_groups1_count 0
    ifelse length passenger_groups1 > 0 ; If there are passengers on board
    [
      foreach passenger_groups1 ; For every passenger group that is waiting
      [ 
        let passenger_group1 ?  ; The passenger group [destination_id group_size]
        
        let destination_id item 0 passenger_group1 ; The destination of the passenger group
        let group_size     item 1 passenger_group1 ; The group size
        
        let xw item destination_id xs * group_size ; x coordinate of the destination bus stop times the amount of passengers
        let yw item destination_id ys * group_size ; y coordinate of the destination bus stop times the amount of passengers
        
        set r1 ( list ( item 0 r1 + xw ) ( item 1 r1 + yw ) ) ; Increment r1 vector
        set passenger_groups1_count passenger_groups1_count + group_size
      ]
      set r1 ( list ( item 0 r1 / passenger_groups1_count ) ( item 1 r1 / passenger_groups1_count ) ) ; Normalize with respect to the total amount of passengers in group1
    ]
    [
      set r1 r0 ; If there are no passengers on board set the estimated route equal to original r0
    ]
    
    let available_seats capacity - passenger_groups0_count + drop_off_count ; The amount of passengers the bus is able to pick up
    let pickup_count passenger_groups1_count                                ; The amount of people to be picked up
    if available_seats < passenger_groups1_count ; If the bus is full
    [
      set pickup_count available_seats ; Maximum amount of people that can be picked up
    ]

    ; Set all vectors
    let vs0s1 ( list (item 0 s1 - item 0 s0 ) (item 1 s1 - item 1 s0 ) )
    let vs0r0 ( list (item 0 r0 - item 0 s0 ) (item 1 r0 - item 1 s0 ) )
    let vs1r0 ( list (item 0 r0 - item 0 s1 ) (item 1 r0 - item 1 s1 ) )
    let vs1r1 ( list (item 0 r1 - item 0 s1 ) (item 1 r1 - item 1 s1 ) )
    
    if pickup_count < 1
    [
      set vs1r1 vs1r0 ; If no passengers can be picked up: route1 is route0
    ]                 ; The case where not everyone can be picked up is not considered
    
    ; Product of vectors
    let vs0s1*vs0r0 ( item 0 vs0s1 * item 0 vs0r0 ) + ( item 1 vs0s1 * item 1 vs0r0 )
    let vs1r0*vs1r1 ( item 0 vs1r0 * item 0 vs1r1 ) + ( item 1 vs1r0 * item 1 vs1r1 )
    
    ; Length of vectors
    let len_vs0s1 sqrt( (item 0 vs0s1) ^ 2 + (item 1 vs0s1) ^ 2 ) + 1
    let len_vs1r1 sqrt( (item 0 vs1r1) ^ 2 + (item 1 vs1r1) ^ 2 ) + 1
    let len_vs0r0 sqrt( (item 0 vs0r0) ^ 2 + (item 1 vs0r0) ^ 2 ) + 1
    let len_vs1r0 sqrt( (item 0 vs1r0) ^ 2 + (item 1 vs1r0) ^ 2 ) + 1
    
    report ( 1 / cost_per_patch ) * ( 1 + drop_off_count ) * ln( 1 + exp( vs0s1*vs0r0 / len_vs0s1 ^ 2 ) ) 
                                  + ( 1 + pickup_count   ) * ln( 1 + exp( vs1r0*vs1r1 / len_vs1r1 ^ 2 ) )
  ]
  [
    report -1 ; Invalid score
  ]
end

; find the corresponding passenger ids of a given list of passenger groups to be claimed 
to-report claim-passenger-ids [ busstop claim_passenger_groups ]
  let passenger-ids [] ; init
  let busstop_passengers get-passengers-at-stop busstop ; returns a list of tuples of the form [passenger_id bus_stop]
  foreach busstop_passengers ; loop through passengers at busstop
  [
    let passenger_id item 0 ?
    let destination item 1 ?
    if member? destination claim_passenger_groups ; if destination == claimed group, add passenger_id to list
    [
      set passenger-ids lput passenger_id passenger-ids
    ]
  ]
  
  report passenger-ids ; list of passenger ids corresponding to claimed groups
end

; inform all buses about the passenger ids that are claimed
to communicate-claim 
  let claim claim-passenger-ids next_stop pick_up_passenger_group

  let id 0
  while [ id < buses_count ] [    
    if (id + length graph) != bus_id [
      send-message (id + length graph) (list "claim" claim)
    ]
    set id id + 1   
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; USEFUL DEBUG COMMANDS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;print matrix:dimensions score_matrix ; debug - checks matrix dimensions
  ;matrix:get matrix row-i col-j ;could be used to check scores of others, also see: matrix:get-row matrix row-i
  ;matrix:set matrix row-i col-j new-value ;fill the matrix with the score per person using this command
  ;show "Matrix update: "
  ;print matrix:pretty-print-text score_matrix  

  ;if current_stop != -1 
  ;[
  ; show (word "Passengers at current stop " current_stop ": " (get-passengers-at-stop current_stop))    
  ;]
